// src/useBaseQuery.ts
import {
  computed,
  getCurrentScope,
  onScopeDispose,
  reactive,
  readonly,
  toRefs,
  watch
} from "vue-demi";
import { useQueryClient } from "./useQueryClient.js";
import { cloneDeepUnref, shouldThrowError, updateState } from "./utils.js";
function useBaseQuery(Observer, options, queryClient) {
  if (process.env.NODE_ENV === "development") {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const defaultedOptions = computed(() => {
    const clonedOptions = cloneDeepUnref(options);
    if (typeof clonedOptions.enabled === "function") {
      clonedOptions.enabled = clonedOptions.enabled();
    }
    const defaulted = client.defaultQueryOptions(clonedOptions);
    defaulted._optimisticResults = client.isRestoring.value ? "isRestoring" : "optimistic";
    return defaulted;
  });
  const observer = new Observer(client, defaultedOptions.value);
  const state = reactive(observer.getCurrentResult());
  let unsubscribe = () => {
  };
  watch(
    client.isRestoring,
    (isRestoring) => {
      if (!isRestoring) {
        unsubscribe();
        unsubscribe = observer.subscribe((result) => {
          updateState(state, result);
        });
      }
    },
    { immediate: true }
  );
  const updater = () => {
    observer.setOptions(defaultedOptions.value);
    updateState(state, observer.getCurrentResult());
  };
  watch(defaultedOptions, updater);
  onScopeDispose(() => {
    unsubscribe();
  });
  const refetch = (...args) => {
    updater();
    return state.refetch(...args);
  };
  const suspense = () => {
    return new Promise(
      (resolve, reject) => {
        let stopWatch = () => {
        };
        const run = () => {
          if (defaultedOptions.value.enabled !== false) {
            observer.setOptions(defaultedOptions.value);
            const optimisticResult = observer.getOptimisticResult(
              defaultedOptions.value
            );
            if (optimisticResult.isStale) {
              stopWatch();
              observer.fetchOptimistic(defaultedOptions.value).then(resolve, (error) => {
                if (shouldThrowError(defaultedOptions.value.throwOnError, [
                  error,
                  observer.getCurrentQuery()
                ])) {
                  reject(error);
                } else {
                  resolve(observer.getCurrentResult());
                }
              });
            } else {
              stopWatch();
              resolve(optimisticResult);
            }
          }
        };
        run();
        stopWatch = watch(defaultedOptions, run);
      }
    );
  };
  watch(
    () => state.error,
    (error) => {
      if (state.isError && !state.isFetching && shouldThrowError(defaultedOptions.value.throwOnError, [
        error,
        observer.getCurrentQuery()
      ])) {
        throw error;
      }
    }
  );
  const object = toRefs(readonly(state));
  for (const key in state) {
    if (typeof state[key] === "function") {
      object[key] = state[key];
    }
  }
  object.suspense = suspense;
  object.refetch = refetch;
  return object;
}
export {
  useBaseQuery
};
//# sourceMappingURL=useBaseQuery.js.map