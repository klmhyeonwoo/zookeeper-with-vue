// src/useMutationState.ts
import {
  computed,
  getCurrentScope,
  onScopeDispose,
  readonly,
  ref,
  watch
} from "vue-demi";
import { useQueryClient } from "./useQueryClient.js";
import { cloneDeepUnref } from "./utils.js";
function useIsMutating(filters = {}, queryClient) {
  if (process.env.NODE_ENV === "development") {
    if (!getCurrentScope()) {
      console.warn(
        'vue-query composable like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.'
      );
    }
  }
  const client = queryClient || useQueryClient();
  const mutationState = useMutationState(
    {
      filters: computed(() => ({
        ...cloneDeepUnref(filters),
        status: "pending"
      }))
    },
    client
  );
  const length = computed(() => mutationState.value.length);
  return length;
}
function getResult(mutationCache, options) {
  return mutationCache.findAll(options.filters).map(
    (mutation) => options.select ? options.select(
      mutation
    ) : mutation.state
  );
}
function useMutationState(options = {}, queryClient) {
  const filters = computed(() => cloneDeepUnref(options.filters));
  const mutationCache = (queryClient || useQueryClient()).getMutationCache();
  const state = ref(getResult(mutationCache, options));
  const unsubscribe = mutationCache.subscribe(() => {
    const result = getResult(mutationCache, options);
    state.value = result;
  });
  watch(filters, () => {
    state.value = getResult(mutationCache, options);
  });
  onScopeDispose(() => {
    unsubscribe();
  });
  return readonly(state);
}
export {
  useIsMutating,
  useMutationState
};
//# sourceMappingURL=useMutationState.js.map