{"version":3,"sources":["../../src/useMutationState.ts"],"sourcesContent":["import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  ref,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { DeepReadonly, Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  MutationFilters as MF,\n  Mutation,\n  MutationState,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { MaybeRefDeep } from './types'\nimport type { MutationCache } from './mutationCache'\n\nexport type MutationFilters = MaybeRefDeep<MF>\n\nexport function useIsMutating(\n  filters: MutationFilters = {},\n  queryClient?: QueryClient,\n): Ref<number> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const mutationState = useMutationState(\n    {\n      filters: computed(() => ({\n        ...cloneDeepUnref(filters),\n        status: 'pending' as const,\n      })),\n    },\n    client,\n  )\n  const length = computed(() => mutationState.value.length)\n\n  return length\n}\n\nexport type MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>,\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>,\n            )\n          : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): DeepReadonly<Ref<Array<TResult>>> {\n  const filters = computed(() => cloneDeepUnref(options.filters))\n  const mutationCache = (queryClient || useQueryClient()).getMutationCache()\n  const state = ref(getResult(mutationCache, options)) as Ref<Array<TResult>>\n  const unsubscribe = mutationCache.subscribe(() => {\n    const result = getResult(mutationCache, options)\n    state.value = result\n  })\n\n  watch(filters, () => {\n    state.value = getResult(mutationCache, options)\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state)\n}\n"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAcxB,SAAS,cACd,UAA2B,CAAC,GAC5B,aACa;AACb,MAAI,QAAQ,IAAI,aAAa,eAAe;AAC1C,QAAI,CAAC,gBAAgB,GAAG;AACtB,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,eAAe,eAAe;AAE7C,QAAM,gBAAgB;AAAA,IACpB;AAAA,MACE,SAAS,SAAS,OAAO;AAAA,QACvB,GAAG,eAAe,OAAO;AAAA,QACzB,QAAQ;AAAA,MACV,EAAE;AAAA,IACJ;AAAA,IACA;AAAA,EACF;AACA,QAAM,SAAS,SAAS,MAAM,cAAc,MAAM,MAAM;AAExD,SAAO;AACT;AASA,SAAS,UACP,eACA,SACgB;AAChB,SAAO,cACJ,QAAQ,QAAQ,OAAO,EACvB;AAAA,IACC,CAAC,aACE,QAAQ,SACL,QAAQ;AAAA,MACN;AAAA,IACF,IACA,SAAS;AAAA,EACjB;AACJ;AAEO,SAAS,iBACd,UAAyC,CAAC,GAC1C,aACmC;AACnC,QAAM,UAAU,SAAS,MAAM,eAAe,QAAQ,OAAO,CAAC;AAC9D,QAAM,iBAAiB,eAAe,eAAe,GAAG,iBAAiB;AACzE,QAAM,QAAQ,IAAI,UAAU,eAAe,OAAO,CAAC;AACnD,QAAM,cAAc,cAAc,UAAU,MAAM;AAChD,UAAM,SAAS,UAAU,eAAe,OAAO;AAC/C,UAAM,QAAQ;AAAA,EAChB,CAAC;AAED,QAAM,SAAS,MAAM;AACnB,UAAM,QAAQ,UAAU,eAAe,OAAO;AAAA,EAChD,CAAC;AAED,iBAAe,MAAM;AACnB,gBAAY;AAAA,EACd,CAAC;AAED,SAAO,SAAS,KAAK;AACvB;","names":[]}